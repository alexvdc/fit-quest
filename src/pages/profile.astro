---
import Layout from '../layouts/Layout.astro';
---

<Layout title="Profil">
    <div class="profile-page">
        <!-- Header Fixe -->
        <header class="header">
            <a href="/" class="btn-back">
                <i data-lucide="arrow-left"></i>
                Menu
            </a>
            <div class="header-title">PROFIL JOUEUR</div>
        </header>

        <div class="scroll-content">
            <!-- SECTION 1 : PROGRESSION -->
            <section class="player-stats-card">
                <div class="level-circle">
                    <span class="lvl-label">NIV</span>
                    <span id="playerLevel" class="lvl-num">1</span>
                </div>
                
                <div class="xp-container">
                    <div class="xp-info">
                        <span>PROGRESSION</span>
                        <span id="xpText" class="xp-text">0 / 100 XP</span>
                    </div>
                    <div class="xp-bar-bg">
                        <div id="xpFill" class="xp-bar-fill" style="width: 0%"></div>
                    </div>
                    <div class="next-reward">
                        Prochain niveau : <span id="nextUnlock">...</span>
                    </div>
                </div>
            </section>

            <!-- SECTION 2 : GESTION DU DECK -->
            <section class="deck-section">
                <div class="section-header">
                    <h2>MON DECK ACTIF</h2>
                    <span class="deck-count"><span id="activeCount">0</span> CARTES</span>
                </div>
                <p class="section-desc">Cochez les exercices que vous voulez voir appara√Ætre en combat.</p>

                <div id="cardsGrid" class="cards-list">
                    <!-- Inject√© par JS -->
                </div>
            </section>
        </div>
    </div>
</Layout>

<script>
    import { getSave, saveGame } from '../scripts/store.js';
    import { CARDS_DATABASE, CARD_TYPES, LEVEL_CURVE } from '../data/fitquest.js';

    document.addEventListener('astro:page-load', () => {
        let state = getSave();
        
        // --- PATCH DE MIGRATION ---
        // Si la sauvegarde est ancienne, on initialise les champs manquants √† la vol√©e
        let hasChanges = false;
        
        if (!state.playerLevel) { state.playerLevel = 1; hasChanges = true; }
        if (!state.playerXp) { state.playerXp = 0; hasChanges = true; }
        
        // Initialisation du Deck si absent
        if (!Array.isArray(state.unlockedCards)) {
            // Par d√©faut, on d√©bloque les cartes de niveau 1
            state.unlockedCards = CARDS_DATABASE.filter(c => c.unlockLevel === 1).map(c => c.id);
            hasChanges = true;
        }
        if (!Array.isArray(state.activeDeck)) {
            state.activeDeck = [...state.unlockedCards];
            hasChanges = true;
        }

        // Sauvegarde imm√©diate du patch pour √©viter de refaire le calcul
        if (hasChanges) {
            console.log("üõ†Ô∏è Migration de sauvegarde effectu√©e.");
            saveGame(state);
            state = getSave(); // Re-fetch propre
        }

        console.log("üìä Profil charg√©. XP:", state.playerXp, "Niv:", state.playerLevel);
        
        renderStats(state);
        renderDeck(state);
    });

    function renderStats(state) {
        const currentLvl = state.playerLevel || 1;
        const currentXp = state.playerXp || 0;
        
        // Calcul XP
        // On s√©curise l'acc√®s au tableau LEVEL_CURVE
        const nextLevelXp = (LEVEL_CURVE && LEVEL_CURVE[currentLvl]) ? LEVEL_CURVE[currentLvl] : 9999;
        
        const pct = Math.min(100, (currentXp / nextLevelXp) * 100);

        const lvlEl = document.getElementById('playerLevel');
        const xpText = document.getElementById('xpText');
        const xpFill = document.getElementById('xpFill');
        const nextUnlock = document.getElementById('nextUnlock');

        if(lvlEl) lvlEl.innerText = currentLvl;
        if(xpText) xpText.innerText = `${Math.floor(currentXp)} / ${nextLevelXp} XP`;
        if(xpFill) xpFill.style.width = `${pct}%`;

        const nextCard = CARDS_DATABASE.find(c => c.unlockLevel > currentLvl);
        if(nextUnlock) nextUnlock.innerText = nextCard ? `D√©bloque "${nextCard.name}"` : "Niveau Max !";
    }

    function renderDeck(state) {
        const grid = document.getElementById('cardsGrid');
        const countEl = document.getElementById('activeCount');
        if(!grid) return;

        grid.innerHTML = '';
        
        // S√©curit√© suppl√©mentaire : fallback sur des tableaux vides si jamais le patch a √©chou√©
        const unlocked = state.unlockedCards || [];
        const active = state.activeDeck || [];
        
        let activeCount = 0;

        CARDS_DATABASE.forEach(card => {
            const isUnlocked = unlocked.includes(card.id);
            const isActive = active.includes(card.id);
            const typeInfo = CARD_TYPES[card.type];

            if(isActive) activeCount++;

            const el = document.createElement('div');
            el.className = `deck-item ${isUnlocked ? '' : 'locked'} ${isActive ? 'active' : ''}`;
            
            el.innerHTML = `
                <div class="item-icon" style="color:${typeInfo.color}">
                    <i data-lucide="${typeInfo.icon}"></i>
                </div>
                <div class="item-info">
                    <div class="item-name">${card.name}</div>
                    <div class="item-desc">${isUnlocked ? typeInfo.label : `D√©bloqu√© au niv ${card.unlockLevel}`}</div>
                </div>
                <div class="item-action">
                    ${isUnlocked ? `
                        <div class="toggle-switch">
                            <input type="checkbox" ${isActive ? 'checked' : ''} />
                            <span class="slider"></span>
                        </div>
                    ` : `<i data-lucide="lock" size="16"></i>`}
                </div>
            `;

            // Interaction Slider
            if (isUnlocked) {
                const toggle = el.querySelector('input');
                const slider = el.querySelector('.slider');

                if (slider && toggle) {
                    slider.onclick = (e) => {
                        e.stopPropagation();
                        // Correction de logique : on inverse l'√©tat actuel
                        const newState = !toggle.checked;
                        toggle.checked = newState; // Mise √† jour visuelle imm√©diate
                        toggleCard(card.id, newState);
                    };
                }
            }

            grid.appendChild(el);
        });

        if(countEl) countEl.innerText = activeCount;
        if(window['lucide']) window['lucide'].createIcons();
    }

    function toggleCard(cardId, shouldBeActive) {
        let state = getSave();
        
        // S√©curit√© tableaux
        if (!Array.isArray(state.activeDeck)) state.activeDeck = [];

        if (shouldBeActive) {
            if (!state.activeDeck.includes(cardId)) {
                state.activeDeck.push(cardId);
            }
        } else {
            if (state.activeDeck.length <= 3) {
                alert("Il faut au moins 3 cartes actives !");
                renderDeck(state); // Reset visuel force le switch √† revenir
                return;
            }
            state.activeDeck = state.activeDeck.filter(id => id !== cardId);
        }

        saveGame(state);
        
        // Mise √† jour visuelle cibl√©e
        const countEl = document.getElementById('activeCount');
        if(countEl) countEl.innerText = state.activeDeck.length;
        
        // On rafra√Æchit toute la grille pour mettre √† jour les classes .active
        renderDeck(state);
    }
</script>

<style is:global>
    .profile-page {
        height: 100vh; display: flex; flex-direction: column;
        background: radial-gradient(circle at top, #1a1a2e, #000);
    }

    .header {
        padding: 20px; background: rgba(0,0,0,0.5); backdrop-filter: blur(10px);
        display: flex; align-items: center; justify-content: space-between;
        border-bottom: 1px solid rgba(255,255,255,0.05); z-index: 10;
    }
    .header-title { font-family: 'Rajdhani'; font-weight: 800; font-size: 1.2rem; letter-spacing: 2px; color:white; }

    .scroll-content { flex: 1; overflow-y: auto; padding: 20px; max-width: 600px; margin: 0 auto; width: 100%; }

    /* SECTION STATS */
    .player-stats-card {
        background: linear-gradient(135deg, rgba(255,255,255,0.05), rgba(255,255,255,0.01));
        border: 1px solid rgba(255,255,255,0.1);
        border-radius: 20px; padding: 25px;
        display: flex; gap: 20px; align-items: center;
        margin-bottom: 30px;
    }
    .level-circle {
        width: 70px; height: 70px; border-radius: 50%;
        border: 3px solid var(--accent);
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: rgba(139, 92, 246, 0.1);
        box-shadow: 0 0 20px rgba(139, 92, 246, 0.2);
    }
    .lvl-label { font-size: 0.7rem; font-weight: 700; color: var(--accent); }
    .lvl-num { font-size: 1.8rem; font-weight: 900; line-height: 1; color: white; font-family: 'Rajdhani'; }

    .xp-container { flex: 1; }
    .xp-info { display: flex; justify-content: space-between; font-size: 0.8rem; margin-bottom: 5px; color: #aaa; font-family: 'Rajdhani'; font-weight: 700; }
    .xp-bar-bg { height: 10px; background: rgba(0,0,0,0.5); border-radius: 5px; overflow: hidden; margin-bottom: 8px; }
    .xp-bar-fill { height: 100%; background: var(--accent); box-shadow: 0 0 10px var(--accent); transition: width 0.5s ease; }
    .next-reward { font-size: 0.75rem; color: #666; font-style: italic; }

    /* SECTION DECK */
    .section-header { display: flex; justify-content: space-between; align-items: baseline; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 10px; }
    h2 { font-family: 'Rajdhani'; font-weight: 800; font-size: 1.5rem; color: white; margin: 0; }
    .deck-count { font-family: 'Rajdhani'; color: var(--success); font-weight: bold; }
    .section-desc { font-size: 0.8rem; color: #888; margin-bottom: 20px; }

    .cards-list { display: flex; flex-direction: column; gap: 10px; padding-bottom: 50px; }

    .deck-item {
        display: flex; align-items: center; gap: 15px;
        background: rgba(20, 20, 23, 0.6);
        border: 1px solid rgba(255,255,255,0.05);
        padding: 15px; border-radius: 12px;
        transition: 0.2s;
    }
    .deck-item.active { border-color: rgba(139, 92, 246, 0.4); background: rgba(139, 92, 246, 0.05); }
    .deck-item.locked { opacity: 0.5; filter: grayscale(1); pointer-events: none; }

    .item-icon { 
        width: 40px; height: 40px; background: rgba(0,0,0,0.3); border-radius: 8px; 
        display: flex; justify-content: center; align-items: center;
    }
    .item-info { flex: 1; }
    .item-name { font-weight: 700; color: white; font-family: 'Rajdhani'; font-size: 1.1rem; }
    .item-desc { font-size: 0.75rem; color: #777; }

    /* TOGGLE SWITCH CSS */
    .toggle-switch { position: relative; width: 50px; height: 26px; }
    .toggle-switch input { opacity: 0; width: 0; height: 0; }
    .slider {
        position: absolute; cursor: pointer; inset: 0;
        background-color: #333; border-radius: 34px; transition: .4s;
    }
    .slider:before {
        position: absolute; content: ""; height: 20px; width: 20px; left: 3px; bottom: 3px;
        background-color: white; border-radius: 50%; transition: .4s;
    }
    input:checked + .slider { background-color: var(--success); }
    input:checked + .slider:before { transform: translateX(24px); }
</style>